# SM3 哈希算法实现（GM/T 0004-2012）
## 简介
SM3 是中国国家密码管理局发布的密码杂凑算法标准（GM/T 0004-2012），用于数据完整性校验和信息安全领域。本实现为纯 C++ 版本，严格遵循标准规范，支持消息哈希计算，并提供高精度计时功能以评估性能。
SM3 算法具备以下特点：
输出 256 位（32 字节）哈希值
采用 Merkle-Damgård 迭代结构
具备强抗碰撞性和高安全性
适用于数字签名、数据完整性验证等场景

## 原理
SM3 算法的核心流程包括：
### 消息预处理：
将输入消息按 512 位（64 字节）分组
对最后一个不完整分组进行填充（添加 0x80 标志位和 64 位长度信息）
### 消息扩展：
将 512 位消息块扩展为 68 个 32 位字（W0-W67）
进一步生成 64 个压缩用消息字（W0'-W63'），增强算法非线性
### 压缩函数：
基于 8 个 32 位状态寄存器（A-H）进行 64 轮迭代
每轮使用不同常量（T1 用于 0-15 轮，T2 用于 16-63 轮）
通过 Feistel 结构和置换函数（P0、P1）实现状态更新
### 结果输出：
迭代完成后，8 个状态寄存器的值拼接为 256 位哈希结果

## 核心代码解释
### 常量定义
```
namespace SM3_CONST {
    constexpr uint32_t IV[8] = { ... };  // 初始向量，算法规定的初始状态
    constexpr uint32_t T1 = 0x79CC4519;  // 0-15轮常量
    constexpr uint32_t T2 = 0x7A879D8A;  // 16-63轮常量
    constexpr size_t BLOCK_SIZE = 64;    // 消息分组大小（字节）
    constexpr size_t HASH_SIZE = 32;     // 哈希结果长度（字节）
}
```
定义 SM3 算法必需的常量，包括初始向量（IV）、轮常量和分组大小，严格遵循 GM/T 0004-2012 标准。
### 辅助函数
```
inline uint32_t ROTL(uint32_t x, uint8_t n) noexcept {
    return (x << n) | (x >> (32 - n));
}
```
32 位循环左移操作，用于压缩函数中的状态变换，是 SM3 非线性变换的核心组件。
### 压缩函数
```
void sm3_compress(const uint8_t* data, uint32_t h[8])
```
处理单个 512 位消息块的核心函数：

### 消息扩展：生成 W 和 W1 数组，增强算法的扩散性
64 轮迭代：基于 Feistel 结构更新 8 个状态寄存器（A-H）
状态混淆：通过布尔函数（FF、GG）和置换函数（P0）实现非线性变换
结果更新：将迭代结果与初始状态异或，生成中间哈希值
哈希主函数
```
void sm3(const void* data, size_t len, uint8_t hash[SM3_CONST::HASH_SIZE])
```
### SM3 算法的入口函数：

初始化状态寄存器（使用 IV 初始向量）
处理所有完整的 512 位消息块
对剩余数据进行填充（符合 PKCS#7 变体规范）
处理最后一个（或两个）填充块
将最终状态寄存器的值转换为大端序哈希结果

### 主函数
```
int main()
```

## 示例代码功能：

对测试消息计算 SM3 哈希值
使用 Windows 高精度计时器（QueryPerformanceCounter）测量执行时间
以十六进制格式输出哈希结果和执行时间
使用示例

## 运行结果
<img width="600" height="140" alt="result" src="" />



## 结论
本实现严格遵循 GM/T 0004-2012 标准，完整实现了 SM3 哈希算法的核心功能。通过高精度计时可评估算法性能，适用于需要国密算法支持的信息安全场景。代码结构清晰，注释详尽，便于理解和二次开发。
## 参考标准
《GM/T 0004-2012 密码杂凑算法 SM3》
